{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"pytest-respect","text":"<p>Pytest plugin to load resource files relative to test code and to expect values to match such files. The name is a contraction of <code>resources.expect</code>, which is frequently typed when using this plugin.</p>"},{"location":"#motivation","title":"Motivation","text":"<p>The primary use-case is running tests over moderately large datasets where adding them as constants in the test code would be cumbersome. This happens frequently with integration tests or when retrofitting tests onto an existing code-base. If you find your test code being obscured by the test data, filling with complex data generation code, or ad-hoc reading of input data or expected results, then pytest-respect is for you.</p>"},{"location":"#installation","title":"Installation","text":"<p>Install with your favourite package manager such as:</p> <ul> <li><code>pip install pydantic-respect</code></li> <li><code>poetry add --dev pydantic-respect</code></li> <li><code>uv add --dev pydantic-respect</code></li> </ul> <p>See your package management tool for details, especially on how to install optional extra dependencies.</p>"},{"location":"#extras","title":"Extras","text":"<p>The following extra dependencies are required for additional functionality:</p> <ul> <li><code>poetry</code> - Load, save, and expect pydantic models or arbitrary data through type adapters.</li> <li><code>numpy</code> - Convert numpy arrays and scalars to python equivalents when generating JSON, both in save and expect.</li> <li><code>jsonyx</code> - Alternative JSON encoder for semi-compact files, numeric keys, trailing commas, etc.</li> </ul>"},{"location":"#usage","title":"Usage","text":""},{"location":"#text-data","title":"Text Data","text":"<p>The simplest use-case is loading textual input data and comparing textual output to an expectation file:</p> <pre><code>def test_translate(resources):\n    input = resources.load_text(\"input\")\n    output = translate(input)\n    resources.expect_text(output, \"output\")\n</code></pre> <p>If the test is found in a file called <code>foo/test_stuff.py</code>, then it will load the content of <code>foo/test_stuff/test_translate__input.txt</code>, run the <code>translate</code> function on it, and assert that the output exactly matches the content of the file <code>foo/test_stuff/test_translate__output.json</code>.</p> <p>The expectation must also match on trailing spaces and trailing empty lines for the test to pass.</p>"},{"location":"#json-data","title":"Json Data","text":"<p>A much more interesting example is doing the same with JSON data:</p> <pre><code>def test_compute(resources):\n    input = resources.load_json(\"input\")\n    output = compute(input)\n    resources.expect_json(output, \"output\")\n</code></pre> <p>This will load the content of <code>foo/test_stuff/test_compute__input.json</code>, run the <code>compute</code> function on it, and assert that the output exactly matches the content of the file <code>foo/test_stuff/test_compute__output.json</code>.</p> <p>The expectation matching is done on a text representation of the JSON data. This avoids having to parse the expectation files, and allows us to use text-based diff tools, but instead we must avoid other tools reformating the expectations. By default the JSON formatting is by <code>json.dumps(obj, sort_keys=True, indent=2)</code> but see the section on JSON Formatting and Parsing.</p>"},{"location":"#pydantic-models","title":"Pydantic Models","text":"<p>With the optional <code>pydantic</code> extra, the same can be done with pydantic data if you have models for your input and output data:</p> <pre><code>def test_compute(resources):\n    input: InputModel = resources.load_pydantic(InputModel, \"input\")\n    output: OutputModel = compute(input)\n    resources.expect_pydantic(output, \"output\")\n</code></pre> <p>The input and output paths will be identical to the JSON test, since we re-used the name of the test function.</p>"},{"location":"#todo-resource-path-construction","title":"TODO: Resource Path Construction","text":"<p>To Document:</p> <ul> <li>Multiple path parts</li> <li>Default path maker</li> <li>Alternative path makers</li> <li>Custom path makers</li> </ul>"},{"location":"#failing-tests","title":"Failing Tests","text":"<p>If an expectation fails, then a new file is created containing the actual value passed to the expect function. Its path is constructed in the same way as that of the expectation file, but with an <code>actual</code> part appended. So in the JSON and Pydantic examples above, it would create the file <code>foo/test_stuff/test_compute__output__actual.json</code>. In addition to this, the normal pytest assert re-writing is done to show the difference between the expected value and the actual value.</p> <p>When the values being compared are more complex, the difference shown on the console may be overwhelming. Then you can instead use your existing diff tools to compare the expected and actual values and perhaps pick individual changes from the actual file before fixing the code to deal with any remaining differences.</p> <p>Once the test passes, the <code>__actual</code> file will be removed. Note that if you change the name of a test after an actual file has been created, then it will have to be deleted manually.</p> <p>Alternatively, if you know that all the actual files from a test run are correct, you can run the test with the <code>--respect-accept</code> flag to update all the expectations. You can also use the <code>--respect-accept-one</code> and <code>--respect-accept-max=n</code> flags to update only a single expectation or the first <code>n</code> expectations before failing on any remaining differences.</p>"},{"location":"#parametric-tests","title":"Parametric Tests","text":"<p>The load and expect (and other) methods can take multiple strings for the resource file name <code>parts</code>. In the earlier examples we only used <code>\"input\"</code> and <code>\"output\"</code> parts and failures implicitly added an <code>\"actual\"</code> part. We can pass in as many parts as we like, which nicely brings us to parametric tests:</p> <pre><code>@pytest.mark.paramtrize(\"case\", [\"red\", \"green\", \"blue\"])\ndef test_compute(resources, case):\n    input = resources.load_json(\"input\", case)\n    output = compute(input)\n    resources.expect_json(output, \"output\", case)\n</code></pre> <p>Omitting the directory name, this test will load each of <code>test_compute__input__red.json</code>, <code>test_compute__input__green.json</code>, <code>test_compute__input__blue.json</code> and compare the results to <code>test_compute__output__red.json</code>, <code>test_compute__output__green.json</code>, <code>test_compute__output__blue.json</code></p>"},{"location":"#data-driven-parametric-tests","title":"Data-driven Parametric Tests","text":"<p>We can use the <code>list_resources</code> function to generate a list of resource names to run parametric tests over. With the below fixture, the content of the resource directory is listed, and the fixture is run once for each match. We can then add test cases simply by adding new resource files:</p> <pre><code>@pytest.fixture(params=list_resources(\"widget_*.json\", exclude=[\"*__actual.json\"], strip_ext=True))\ndef each_widget_name(request) -&gt; str:\n    \"\"\"Request this fixture to run for each widget file in the resource directory.\"\"\"\n    return request.param\n</code></pre> <p>The <code>list_resources</code> function is run in a static context and so doesn't have a test function or class to build paths from. Instead, it constructs a path to the file that it is called from and uses the <code>pm_only_file</code> path maker by default. However, it takes an optional <code>path_maker</code> argument to override this.</p> <p>Tests can then request <code>each_widget_name</code> to run on each of the resources but will have to use a suitable path-maker to find the resource files:</p> <pre><code>def test_load_json_resource(resources, each_widget_name):\n    widget = resources.load_json(each_widget_name, path_maker=resources.pm_only_file)\n    assert transform(widget) == 42\n</code></pre> <p>To Document:</p> <ul> <li>Using <code>list</code> function</li> </ul>"},{"location":"#json-formatting-and-parsing","title":"JSON Formatting and Parsing","text":""},{"location":"#to-document","title":"To Document:","text":"<ul> <li>Default JSON formatter and parser</li> <li>Alternative JSON formatter</li> <li>Jsonyx extension</li> </ul>"},{"location":"#configuration","title":"Configuration","text":"<p>To Document:</p> <ul> <li>Default path makers</li> <li>Default JSON encoder and loader</li> <li>Default ndigits</li> </ul>"},{"location":"#development","title":"Development","text":""},{"location":"#installation_1","title":"Installation","text":"<ul> <li>Install uv</li> <li>Run <code>uv sync --all-extras</code></li> <li>Run <code>pre-commit install</code> to enable pre-commit linting.</li> <li>Run <code>pytest</code> to verify installation.</li> </ul>"},{"location":"#testing","title":"Testing","text":"<p>This is a pytest plugin so you're expected to know how to run pytest when hacking on it. Additionally, <code>scripts/pytest-extras</code> runs the test suite with different sets of optional extras. The CI Pipelines will go through an equivalent process for each Pull Request.</p>"},{"location":"CHANGES/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"CHANGES/#100-2025-12-2x","title":"[1.0.0] - 2025-12-2x","text":""},{"location":"CHANGES/#added","title":"Added","text":"<ul> <li>In <code>resources</code>, the methods <code>expect_pydantic</code>, <code>save_pydantic</code>, <code>expect_pydantic_adapter</code> and <code>save_pydantic_adapter</code> now accept several new arguments which are passed to the pydantic <code>model_dump</code> or <code>python_dump</code> methods: <code>include</code>, <code>exclude</code>, <code>by_alias</code>, <code>exclude_unset</code>, <code>exclude_defaults</code>, <code>exclude_none</code>, <code>round_trip</code>, <code>serialize_as_any</code>.</li> </ul>"},{"location":"CHANGES/#breaking","title":"Breaking","text":"<ul> <li><code>resources.default.path_maker</code> is now <code>pm_file</code> instead of <code>pm_class</code>. This only affects resources relative to a test <code>some_package.TestSomeThing.test_an_aspect</code> where the base path is now <code>some_package/TestSomeThing__test_an_aspect</code> instead of <code>some_package__TestSomeThing/test_an_aspect</code>. This gives fewer directories next to the test file and less clutter.</li> <li>Made <code>utils._coalesce</code> and <code>utils._JSON_PREPPERS</code> private.</li> <li>Made <code>resources._accept_count</code> private.</li> </ul>"},{"location":"CHANGES/#090-2025-10-21","title":"[0.9.0] - 2025-10-21","text":""},{"location":"CHANGES/#added_1","title":"Added","text":"<ul> <li>Added <code>resources.default</code> structure with defaults for <code>path_maker</code>, <code>json_loader</code>, <code>json_encoder</code> and <code>ndigits</code>.</li> <li>Added optional <code>json_loader</code> argument to: <code>load_json</code>, <code>load_pydantic</code> and <code>load_pydantic_adapter</code> which overrides the default.</li> <li>Added optional <code>json_encoder</code> argument to : <code>data_to_json</code>, <code>save_json</code>, <code>expect_json</code>, <code>save_pydantic</code>, <code>expect_pydantic</code>, <code>save_pydantic_adapter</code>, <code>expect_pydantic_adapter</code> to override the default.</li> <li>Added global list of <code>JSON_PREPPERS</code> and <code>add_json_prepper</code> function to add functions for preparing values of specific types before they are either JSON encoded or recursively descended into in <code>prepare_for_json_encode</code>.</li> <li>Converted the pydantic and numpy special preparations to JSON preppers.</li> <li>Prepare any collection (other than str) recursively as a list</li> <li>Any value, which is not directly JSON encodable and isn't prepared by a JSON prepper, will be prepared using <code>str()</code>.</li> </ul>"},{"location":"CHANGES/#breaking_1","title":"Breaking","text":"<ul> <li><code>resources.default_path_maker</code> was moved to <code>default.path_maker</code> and <code>default_ndigits</code> was moved to <code>default.ndigits</code>.</li> </ul>"},{"location":"CHANGES/#030-2025-08-25","title":"[0.3.0] - 2025-08-25","text":""},{"location":"CHANGES/#added_2","title":"Added","text":"<ul> <li><code>resources.accept</code> property which decides whether to accept a result if it differs from the expectation instead of failing the test.</li> <li><code>--respect-accept</code> command-line option which populates the <code>resources.accept</code> property.</li> </ul>"},{"location":"CHANGES/#changed","title":"Changed","text":"<ul> <li>The <code>jsonyx_encoder</code> variants now allow all JSON deviations. Most notably, they will encode <code>nan</code> values.</li> </ul>"},{"location":"CHANGES/#020-2025-08-18","title":"[0.2.0] - 2025-08-18","text":""},{"location":"CHANGES/#added_3","title":"Added","text":"<ul> <li><code>context</code> argument to <code>resources.expect_pydantic</code> method (#11).</li> <li><code>resources.save_pydantic</code> method which serializes a pydantic model and accepts the new <code>context</code> (#11).</li> <li><code>resources.save_pydantic_adapter</code> method which serializes arbitrary data using a pydantic <code>TypeAdapter</code>. It accepts the new <code>context</code> object in case there are pydantic models somewhere within the data being saved (#11).</li> <li><code>resources.expect_pydantic_adapter</code> method which serializes like <code>save_pydantic_adapter</code> and expects the result to match a resource on-disk (#11).</li> </ul>"},{"location":"CHANGES/#changed_1","title":"Changed","text":"<ul> <li>Generated JSON now converts negative zero (<code>-0.0</code>) to non-negative zero (<code>0.0</code>) (#10).</li> </ul>"},{"location":"CHANGES/#012-2025-08-18","title":"[0.1.2] - 2025-08-18","text":""},{"location":"CHANGES/#fixed","title":"Fixed","text":"<ul> <li>Documentation</li> </ul>"},{"location":"CHANGES/#011-2025-08-06","title":"[0.1.1] - 2025-08-06","text":""},{"location":"CHANGES/#fixed_1","title":"Fixed","text":"<ul> <li>Documentation.</li> </ul>"},{"location":"CHANGES/#010-2025-08-06","title":"[0.1.0] - 2025-08-06","text":""},{"location":"CHANGES/#added_4","title":"Added","text":"<ul> <li>Convert to pytest plugin.</li> </ul>"},{"location":"CHANGES/#fixed_2","title":"Fixed","text":"<ul> <li>Make work without the optional dependencies (#4).</li> </ul>"},{"location":"CHANGES/#001-2025-08-05","title":"[0.0.1] - 2025-08-05","text":"<p>Initial import from Ankeri's proprietary Platform code-base.</p>"},{"location":"api-ext/","title":"<code>pytest_respect.ext.jsonyx</code>","text":"<p>JSON encoders and loaders using the jsonyx library. See https://github.com/nineteendo/jsonyx</p>"},{"location":"api-ext/#pytest_respect.ext.jsonyx.jsonyx_compact_encoder","title":"<code>jsonyx_compact_encoder(obj)</code>","text":"<p>JSONYX encoder which allows non-string dict keys. Here it runs in very compact mode.</p> Source code in <code>src/pytest_respect/ext/jsonyx.py</code> <pre><code>def jsonyx_compact_encoder(obj: Any) -&gt; str:\n    \"\"\"JSONYX encoder which allows non-string dict keys.\n    Here it runs in very compact mode.\"\"\"\n    import jsonyx.allow\n\n    return jsonyx.dumps(\n        obj,\n        sort_keys=True,\n        allow=jsonyx.allow.EVERYTHING,\n    )\n</code></pre>"},{"location":"api-ext/#pytest_respect.ext.jsonyx.jsonyx_compactish_encoder","title":"<code>jsonyx_compactish_encoder(obj)</code>","text":"<p>JSONYX encoder which allows non-string dict keys. Here it runs in a semi-compact mode where arrays and dicts containing only primitives are not indented.</p> Source code in <code>src/pytest_respect/ext/jsonyx.py</code> <pre><code>def jsonyx_compactish_encoder(obj: Any) -&gt; str:\n    \"\"\"JSONYX encoder which allows non-string dict keys.\n    Here it runs in a semi-compact mode where arrays and dicts containing only primitives are not indented.\"\"\"\n    import jsonyx.allow\n\n    return jsonyx.dumps(\n        obj,\n        sort_keys=True,\n        indent=2,\n        indent_leaves=False,\n        allow=jsonyx.allow.EVERYTHING,\n    )\n</code></pre>"},{"location":"api-ext/#pytest_respect.ext.jsonyx.jsonyx_encoder","title":"<code>jsonyx_encoder(obj)</code>","text":"<p>JSONYX encoder which allows non-string dict keys. Here it runs in very verbose mode.</p> Source code in <code>src/pytest_respect/ext/jsonyx.py</code> <pre><code>def jsonyx_encoder(obj: Any) -&gt; str:\n    \"\"\"JSONYX encoder which allows non-string dict keys.\n    Here it runs in very verbose mode.\"\"\"\n    import jsonyx.allow\n\n    return jsonyx.dumps(\n        obj,\n        sort_keys=True,\n        indent=2,\n        allow=jsonyx.allow.EVERYTHING,\n    )\n</code></pre>"},{"location":"api-ext/#pytest_respect.ext.jsonyx.jsonyx_permissive_loader","title":"<code>jsonyx_permissive_loader(text)</code>","text":"<p>JSONYX loader in very permissive mode.</p> Source code in <code>src/pytest_respect/ext/jsonyx.py</code> <pre><code>def jsonyx_permissive_loader(text: str) -&gt; Any:\n    \"\"\"JSONYX loader in very permissive mode.\"\"\"\n    import jsonyx.allow\n\n    return jsonyx.loads(text, allow=jsonyx.allow.EVERYTHING)\n</code></pre>"},{"location":"api-resources/","title":"<code>pytest_respect.resources</code>","text":"<p>Contains the <code>TestResources</code> class implementing the <code>resources</code> fixture along with various helpers.</p>"},{"location":"api-resources/#pytest_respect.resources.JsonEncoder","title":"<code>JsonEncoder = Callable[[Any], str]</code>  <code>module-attribute</code>","text":"<p>Type for functions to convert data to JSON encoded text.</p>"},{"location":"api-resources/#pytest_respect.resources.JsonLoader","title":"<code>JsonLoader = Callable[[str], Any]</code>  <code>module-attribute</code>","text":"<p>Type for functions to convert JSON encoded text to python data.</p>"},{"location":"api-resources/#pytest_respect.resources.PathParts","title":"<code>PathParts = tuple[Path, str | None]</code>  <code>module-attribute</code>","text":"<p>Directory and base file-name for a resource path, returned by PathMakers when locating resources.</p>"},{"location":"api-resources/#pytest_respect.resources.Defaults","title":"<code>Defaults</code>","text":"<p>Default settings for a TestResources instance. These can be set via <code>resources.default.foo</code> and usually overridden in individual calls to <code>resources</code> methods.</p> Source code in <code>src/pytest_respect/resources.py</code> <pre><code>class Defaults:\n    \"\"\"Default settings for a TestResources instance. These can be set via `resources.default.foo` and usually\n    overridden in individual calls to `resources` methods.\"\"\"\n\n    def __init__(self):\n        self.ndigits: int | None = None\n        \"\"\"How many digits to round floats to by default when comparing JSON data.\"\"\"\n\n        self.json_encoder: JsonEncoder = python_json_encoder\n        \"\"\"Function used to convert data to JSON encoded text. Defaults to standard python JSON encoding.\"\"\"\n\n        self.json_loader: JsonLoader = python_json_loader\n        \"\"\"Function used to convert JSON encoded text to python data. Defaults to standard python JSON decoding.\"\"\"\n\n        self.path_maker: PathMaker = TestResources.pm_file\n        \"\"\"\n        Function used to make paths to resources. Defaults to pm_file making resource paths like\n        ``&lt;dir&gt;/test_file/test_function.&lt;ext&gt;``, or  ``&lt;dir&gt;/test_file/TestClass__test_method.&lt;ext&gt;`` if the test is\n        within a class.\n        \"\"\"\n\n    def _ndigits(self, value: int | None | EllipsisType) -&gt; int | None:\n        \"\"\"Resolve ndigits given the default value here and optional override.\"\"\"\n        return _coalesce(self.ndigits, value, nonable=True)\n\n    def _json_encoder(self, value: JsonEncoder | None | EllipsisType) -&gt; JsonEncoder:\n        \"\"\"Resolve json_encoder given the default value here and optional override.\"\"\"\n        return _coalesce(self.json_encoder, value)\n\n    def _json_loader(self, value: JsonLoader | None | EllipsisType) -&gt; JsonLoader:\n        \"\"\"Resolve json_loader given the default value here and optional override.\"\"\"\n        return _coalesce(self.json_loader, value)\n\n    def _path_maker(self, value: PathMaker | None | EllipsisType) -&gt; PathMaker:\n        \"\"\"Resolve path_maker given the default value here and optional override.\"\"\"\n        return _coalesce(self.path_maker, value)\n</code></pre>"},{"location":"api-resources/#pytest_respect.resources.Defaults.json_encoder","title":"<code>json_encoder = python_json_encoder</code>  <code>instance-attribute</code>","text":"<p>Function used to convert data to JSON encoded text. Defaults to standard python JSON encoding.</p>"},{"location":"api-resources/#pytest_respect.resources.Defaults.json_loader","title":"<code>json_loader = python_json_loader</code>  <code>instance-attribute</code>","text":"<p>Function used to convert JSON encoded text to python data. Defaults to standard python JSON decoding.</p>"},{"location":"api-resources/#pytest_respect.resources.Defaults.ndigits","title":"<code>ndigits = None</code>  <code>instance-attribute</code>","text":"<p>How many digits to round floats to by default when comparing JSON data.</p>"},{"location":"api-resources/#pytest_respect.resources.Defaults.path_maker","title":"<code>path_maker = TestResources.pm_file</code>  <code>instance-attribute</code>","text":"<p>Function used to make paths to resources. Defaults to pm_file making resource paths like <code>&lt;dir&gt;/test_file/test_function.&lt;ext&gt;</code>, or  <code>&lt;dir&gt;/test_file/TestClass__test_method.&lt;ext&gt;</code> if the test is within a class.</p>"},{"location":"api-resources/#pytest_respect.resources.PathMaker","title":"<code>PathMaker</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol for functions which determine a directory and base file-name from the location of a test function.</p> Source code in <code>src/pytest_respect/resources.py</code> <pre><code>class PathMaker(Protocol):\n    \"\"\"Protocol for functions which determine a directory and base file-name from the location of a test function.\"\"\"\n\n    def __call__(\n        self,\n        test_dir: Path,\n        test_file_name: str,\n        test_class_name: str | None,\n        test_name: str,\n    ) -&gt; PathParts: ...\n</code></pre>"},{"location":"api-resources/#pytest_respect.resources.TestResources","title":"<code>TestResources</code>","text":"<p>Implements the <code>resources</code> pytest fixture.</p> Source code in <code>src/pytest_respect/resources.py</code> <pre><code>class TestResources:\n    \"\"\"\n    Implements the `resources` pytest fixture.\n\n    \"\"\"\n\n    __test__ = False  # Don't try to collect this as a test\n\n    def __init__(self, request: FixtureRequest, accept_count: int = 0):\n        \"\"\"Create test resources instance, usually in a function-scoped fixture.\n\n        Args:\n            request: The pytest fixture request object.\n            accept_count: Accept the actual results for this many mismatches before failing the test.\n\n        \"\"\"\n        self.request: FixtureRequest = request\n        \"\"\"The pytest fixture request that we get context information from.\"\"\"\n\n        self._accept_count: int = accept_count\n        \"\"\"Mimatches remaining before we fail the test.\"\"\"\n\n        self.default: Defaults = Defaults()\n        \"\"\"Default behaviours. They can be optionally overridden in methods that use them.\"\"\"\n\n        self._extra_preppers: list[tuple[type | UnionType, Callable[[Any], Any]]] = []\n        \"\"\"JSON Preppers to apply after the global JSON_PREPPERS.\"\"\"\n\n    # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #\n    # Path Makers\n\n    @staticmethod\n    def pm_function(test_dir: Path, test_file_name: str, test_class_name: str | None, test_name: str) -&gt; PathParts:\n        \"\"\"PathMaker to build directory from test_file, class if present, and function. No contribution is made to the\n        file name.\n\n        - ``&lt;dir&gt;/test_file__test_function/data.&lt;ext&gt;``\n        - ``&lt;dir&gt;/test_file__TestClass__test_method/data.&lt;ext&gt;``\n        \"\"\"\n        if test_class_name:\n            dir = test_dir / f\"{test_file_name}__{test_class_name}__{test_name}\"\n        else:\n            dir = test_dir / f\"{test_file_name}__{test_name}\"\n\n        return dir, None\n\n    @staticmethod\n    def pm_class(test_dir: Path, test_file_name: str, test_class_name: str | None, test_name: str) -&gt; PathParts:\n        \"\"\"PathMaker to build directory from test_file and class if present, and file-name from test method.\n\n        This is the default method for constructing resource paths.\n\n        - ``&lt;dir&gt;/test_file/test_function.&lt;ext&gt;``\n        - ``&lt;dir&gt;/test_file__TestClass/test_method.&lt;ext&gt;``\n        \"\"\"\n        if test_class_name:\n            dir = test_dir / f\"{test_file_name}__{test_class_name}\"\n        else:\n            dir = test_dir / test_file_name\n        return dir, test_name\n\n    @staticmethod\n    def pm_only_class(test_dir: Path, test_file_name: str, test_class_name: str | None, test_name: str) -&gt; PathParts:\n        \"\"\"PathMaker to build directory from test_file and class if present and contribute nothing to the file-name\n\n        - ``&lt;dir&gt;/test_file__TestClass/data.&lt;ext&gt;``\n        - ``&lt;dir&gt;/test_file/data.&lt;ext&gt;``\n        \"\"\"\n        if test_class_name:\n            dir = test_dir / f\"{test_file_name}__{test_class_name}\"\n        else:\n            dir = test_dir / test_file_name\n        return dir, None\n\n    @staticmethod\n    def pm_file(test_dir: Path, test_file_name: str, test_class_name: str | None, test_name: str) -&gt; PathParts:\n        \"\"\"PathMaker to build directory from test_file and file-name from test class if present, and test method.\n\n        - ``&lt;dir&gt;/test_file/test_function.&lt;ext&gt;``\n        - ``&lt;dir&gt;/test_file/TestClass__test_method.&lt;ext&gt;``\n        \"\"\"\n        if test_class_name:\n            file = f\"{test_class_name}__{test_name}\"\n        else:\n            file = test_name\n        return test_dir / test_file_name, file\n\n    @staticmethod\n    def pm_only_file(\n        test_dir: Path,\n        test_file_name: str,\n        test_class_name: str | None = None,\n        test_name: str | None = None,\n    ) -&gt; tuple[Path, str | None]:\n        \"\"\"PathMaker to build directory from test_file and contribute to the file-name.\n\n        - ``&lt;dir&gt;/test_file/data.&lt;ext&gt;``\n        \"\"\"\n        return test_dir / test_file_name, None\n\n    @staticmethod\n    def pm_dir(test_dir: Path, test_file_name: str, test_class_name: str | None, test_name: str) -&gt; PathParts:\n        \"\"\"PathMaker to use \"resources\" for directory and build file-name from test file, test class if present and\n        test function.\n\n        - ``&lt;dir&gt;/resources/test_file__test_function.&lt;ext&gt;``\n        - ``&lt;dir&gt;/resources/test_file__TestClass__test_method.&lt;ext&gt;``\n        \"\"\"\n        path_maker = TestResources.pm_dir_named(DEFAULT_RESOURCES_DIR)\n        return path_maker(test_dir, test_file_name, test_class_name, test_name)\n\n    @staticmethod\n    def pm_dir_named(dir_name: str = DEFAULT_RESOURCES_DIR) -&gt; PathMaker:\n        \"\"\"PathMaker to use the given name for directory and build file-name from test file, test class if present and\n        test function.\n\n        - ``&lt;dir&gt;/&lt;dir_name&gt;/test_file__test_function.&lt;ext&gt;``\n        - ``&lt;dir&gt;/&lt;dir_name&gt;/test_file__TestClass__test_method.&lt;ext&gt;``\n        \"\"\"\n\n        def path_from_dir(\n            test_dir: Path,\n            test_file_name: str,\n            test_class_name: str | None,\n            test_name: str,\n        ) -&gt; PathParts:\n            if test_class_name:\n                file = f\"{test_file_name}__{test_class_name}__{test_name}\"\n            else:\n                file = f\"{test_file_name}__{test_name}\"\n            return test_dir / dir_name, file\n\n        return path_from_dir\n\n    @staticmethod\n    def pm_only_dir(\n        test_dir: Path,\n        test_file_name: str,\n        test_class_name: str | None = None,\n        test_name: str | None = None,\n    ) -&gt; PathParts:\n        \"\"\"Use \"resources\" for directory and nothing for the file-name.\"\"\"\n        return test_dir / DEFAULT_RESOURCES_DIR, None\n\n    @staticmethod\n    def pm_only_dir_named(dir_name: str = DEFAULT_RESOURCES_DIR) -&gt; PathMaker:\n        \"\"\"Use the given name for directory nothing for the file-name.\"\"\"\n\n        def path_from_dir(\n            test_dir: Path,\n            test_file_name: str,\n            test_class_name: str | None,\n            test_name: str,\n        ) -&gt; PathParts:\n            return test_dir / dir_name, None\n\n        return path_from_dir\n\n    # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #\n    # Paths\n\n    def dir(self, path_maker: PathMaker | None = None) -&gt; Path:\n        \"\"\"Directory for resources belonging to the test.\n\n        Args:\n            path_maker: Function to turn test co-ordinates into a directory and partial\n                file-name for the resource. The file part will be ignored.\n\n        \"\"\"\n        path_maker = self.default._path_maker(path_maker)\n        test_file = Path(self.request.node.fspath)\n        test_class: type | None = self.request.node.cls\n\n        dir_path, base_name = path_maker(\n            test_dir=test_file.parent,\n            test_file_name=test_file.name.rsplit(\".\", 1)[0],\n            test_class_name=test_class.__name__ if test_class else None,\n            test_name=self.request.node.originalname,\n        )\n\n        return dir_path\n\n    def path(\n        self,\n        *parts: Any,\n        ext: str | None = None,\n        path_maker: PathMaker | None = None,\n    ) -&gt; Path:\n        \"\"\"Path to a resource file within this test file/class's directory.\n\n        Args:\n            parts: Concatenate these parts to the function name, with __ separator to\n                make file-name.\n            ext: Add this extension to the file-name if not already present. Defaults\n                to nothing which can be appropriate if we knot that the last ``part``\n                already has an extension.\n            path_maker: Function to turn test co-ordinates into a directory and partial\n                file-name for the resource. Defaults to one which uses the test file\n                (and class if present) for the dir and the test function for the file.\n\n        \"\"\"\n        path_maker = self.default._path_maker(path_maker)\n        test_file = Path(self.request.node.fspath)\n        test_class: type | None = self.request.node.cls\n\n        dir_path, base_name = path_maker(\n            test_dir=test_file.parent,\n            test_file_name=test_file.name.rsplit(\".\", 1)[0],\n            test_class_name=test_class.__name__ if test_class else None,\n            test_name=self.request.node.originalname,\n        )\n\n        name_parts: list[str] = []\n        if base_name:\n            name_parts.append(base_name)\n        name_parts.extend(map(str, parts))\n        if not name_parts:\n            # If we have not file-name parts from anywhere, then fall back to \"data\"\n            name_parts = [\"data\"]\n\n        name = \"__\".join(name_parts)\n        if ext and not name.endswith(f\".{ext}\"):\n            name = f\"{name}.{ext}\"\n        return dir_path / name\n\n    # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #\n    # List Resources\n\n    def list(\n        self,\n        include: str | Sequence[str] = \"*\",\n        *,\n        exclude: str | Sequence[str] = tuple(),\n        path_maker: PathMaker | None = None,\n        strip_ext: str | bool = False,\n    ) -&gt; list[str]:\n        \"\"\"List the names of the resources in the folder.\n\n        Args:\n            include: one or more glob patterns for filenames to include\n            exclude: zero or more glob patterns for filenames to exclude\n            path_maker: Function to turn test co-ordinates into a directory and partial\n                file-name for the resource. The file part will be ignored.\n        strip_ext: Whether to strip extension from listed resource file names. If\n            True or False then strip all or no extensions from last dot.\n            If string, then strip only that string from the ends of file names. A\n            strip_ext string must include the dot (if wanted) to allow stripping\n            suffixes such as `__bad.json`\n\n        \"\"\"\n        dir: Path = self.dir(path_maker)\n        return list_dir(dir, include, exclude=exclude, strip_ext=strip_ext)\n\n    def delete(\n        self,\n        *parts,\n        ext: str | None = None,\n        path_maker: PathMaker | None = None,\n    ):\n        \"\"\"Delete a string resource relative to the current test.\"\"\"\n        path = self.path(*parts, ext=ext, path_maker=path_maker)\n        path.unlink(missing_ok=True)\n\n    # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #\n    # Text Resources\n\n    def load_text(\n        self,\n        *parts,\n        ext: str = \"txt\",\n        path_maker: PathMaker | None = None,\n    ) -&gt; str:\n        \"\"\"Load a string resource relative to the current test.\"\"\"\n        path = self.path(*parts, ext=ext, path_maker=path_maker)\n        return path.read_text()\n\n    def save_text(\n        self,\n        text: str,\n        *parts,\n        ext: str = \"txt\",\n        path_maker: PathMaker | None = None,\n    ) -&gt; None:\n        \"\"\"Write a string to a resource relative to the current test.\"\"\"\n        path = self.path(*parts, ext=ext, path_maker=path_maker)\n        if not path.parent.exists():\n            path.parent.mkdir(parents=True, exist_ok=True)\n        print(f\"write {len(text)} chars to {path}\")\n        path.parent.mkdir(parents=False, exist_ok=True)\n        path.write_text(text)\n\n    def delete_text(\n        self,\n        *parts,\n        ext: str = \"txt\",\n        path_maker: PathMaker | None = None,\n    ):\n        \"\"\"Delete a json resource relative to the current test.\"\"\"\n        self.delete(*parts, ext=ext, path_maker=path_maker)\n\n    def expect_text(\n        self,\n        actual: str,\n        *parts,\n        ext: str = \"txt\",\n        path_maker: PathMaker | None = None,\n    ) -&gt; None:\n        \"\"\"Assert that the actual value matches the content from resource.\"\"\"\n        expected_path = self.path(*parts, ext=ext, path_maker=path_maker)\n        actual_path = self.path(*parts, \"actual\", ext=ext, path_maker=path_maker)\n\n        if not expected_path.is_file():\n            expected_path.parent.mkdir(parents=False, exist_ok=True)\n            if self._accept_one():\n                expected_path.write_text(actual)\n                print(f\"A new expectation file was written to {expected_path}.\")\n                actual_path.unlink(missing_ok=True)\n            else:\n                actual_path.write_text(actual)\n                raise AssertionError(\n                    f\"The expectation file was not found at {expected_path}. \"\n                    f\"The actual value has been written to {actual_path}.\"\n                )\n\n        expected = expected_path.read_text()\n\n        try:\n            assert actual == expected, (\n                f\"The actual value did not match the content of {expected_path}. \"\n                f\"It has been written to {actual_path} for comparison.\"\n            )\n            if actual_path.exists():\n                actual_path.unlink(missing_ok=True)\n                print(\"removing matching actual file\", actual_path)\n        except AssertionError:\n            if self._accept_one():\n                print(f\"The expectation file was updated at {expected_path}.\")\n                expected_path.write_text(actual)\n                actual_path.unlink(missing_ok=True)\n            else:\n                actual_path.write_text(actual)\n                raise\n\n    def _accept_one(self) -&gt; bool:\n        \"\"\"Whether to accept one more mismatch before failing the test.\"\"\"\n        self._accept_count -= 1\n        return self._accept_count &gt;= 0\n\n    # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #\n    # JSON Resources\n\n    def add_json_prepper(self, type_: type | UnionType, prepper: Callable[[Any], Any]) -&gt; None:\n        \"\"\"Register a local JSON prepper for a given type, including sub-classes.\n\n        The prepper can return a few kinds of values:\n\n        - Simple value: encoded as-is and must be JSON serializable.\n        - Dict: encoded recursively but must have keys that are supported by the json_encoder in use, usually str.\n        - Collection: list, tuple, set, etc will be recursively encoded as a list.\n\n        It can also raise AbortJsonPrep to skip this prepper and continue trying others.\n        \"\"\"\n        self._extra_preppers.append((type_, prepper))\n\n    def load_json(\n        self,\n        *parts,\n        ext: str = \"json\",\n        path_maker: PathMaker | None = None,\n        json_loader: JsonLoader | EllipsisType = ...,\n    ) -&gt; Any:\n        \"\"\"Load a json resource relative to the current test.\"\"\"\n        path = self.path(*parts, ext=ext, path_maker=path_maker)\n        try:\n            text = path.read_text()\n            json_loader = self.default._json_loader(json_loader)\n            return json_loader(text)\n        except Exception as e:\n            raise ValueError(f\"Failed to load JSON resource {path}: {repr(e)}\") from e\n\n    def data_to_json(\n        self,\n        data: Any,\n        json_encoder: JsonEncoder | EllipsisType = ...,\n        ndigits: int | None | EllipsisType = ...,\n    ) -&gt; str:\n        \"\"\"Convert data to a json string used for both expectations and save_json.\"\"\"\n        ndigits = self.default._ndigits(ndigits)\n        data = prepare_for_json_encode(data, ndigits=ndigits, extra_preppers=self._extra_preppers)\n        json_encoder = self.default._json_encoder(json_encoder)\n        text = json_encoder(data)\n        if not text.endswith(\"\\n\"):\n            text += \"\\n\"\n        return text\n\n    def save_json(\n        self,\n        data: Any,\n        *parts,\n        ext: str = \"json\",\n        path_maker: PathMaker | None = None,\n        json_encoder: JsonEncoder | EllipsisType = ...,\n        ndigits: int | None | EllipsisType = ...,\n    ) -&gt; None:\n        \"\"\"Write JSON data to a resource relative to the current test.\"\"\"\n        text = self.data_to_json(data, json_encoder=json_encoder, ndigits=ndigits)\n        self.save_text(text, *parts, ext=ext, path_maker=path_maker)\n\n    def delete_json(\n        self,\n        *parts,\n        ext: str = \"json\",\n        path_maker: PathMaker | None = None,\n    ):\n        \"\"\"Delete a json resource relative to the current test.\"\"\"\n        self.delete(*parts, ext=ext, path_maker=path_maker)\n\n    def expect_json(\n        self,\n        actual: Any,\n        *parts,\n        ext: str = \"json\",\n        path_maker: PathMaker | None = None,\n        json_encoder: JsonEncoder | EllipsisType = ...,\n        ndigits: int | None | EllipsisType = ...,\n    ) -&gt; None:\n        \"\"\"Assert that the actual value encodes to the JSON content from resource.\"\"\"\n        actual_text = self.data_to_json(actual, json_encoder=json_encoder, ndigits=ndigits)\n        self.expect_text(\n            actual_text,\n            *parts,\n            ext=ext,\n            path_maker=path_maker,\n        )\n\n    # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #\n    # Pydantic Resources\n\n    def load_pydantic(\n        self,\n        model_class: type[PMT],\n        *parts,\n        ext: str = \"json\",\n        path_maker: PathMaker | None = None,\n        json_loader: JsonLoader | EllipsisType = ...,\n    ) -&gt; PMT:\n        \"\"\"Load a pydantic resource relative to the current test.\"\"\"\n        data = self.load_json(*parts, ext=ext, path_maker=path_maker, json_loader=json_loader)\n        return model_class.model_validate(data)\n\n    def save_pydantic(\n        self,\n        data: Any,\n        *parts,\n        ext: str = \"json\",\n        path_maker: PathMaker | None = None,\n        json_encoder: JsonEncoder | EllipsisType = ...,\n        ndigits: int | None | EllipsisType = ...,\n        # Optional arguments for data.model_dump\n        context: Any = None | EllipsisType,\n        include: Any | EllipsisType = ...,\n        exclude: Any | EllipsisType = ...,\n        by_alias: bool | None | EllipsisType = ...,\n        exclude_unset: bool | EllipsisType = ...,\n        exclude_defaults: bool | EllipsisType = ...,\n        exclude_none: bool | EllipsisType = ...,\n        round_trip: bool | EllipsisType = ...,\n        serialize_as_any: bool | EllipsisType = ...,\n    ) -&gt; None:\n        \"\"\"Write pydantic data to a resource relative to the current test.\"\"\"\n        # Avoid arguments that are not explicitly set to avoid pydantic version problems\n        options = _dict_without_ellipsis(\n            context=context,\n            include=include,\n            exclude=exclude,\n            by_alias=by_alias,\n            exclude_unset=exclude_unset,\n            exclude_defaults=exclude_defaults,\n            exclude_none=exclude_none,\n            round_trip=round_trip,\n            serialize_as_any=serialize_as_any,\n        )\n        dumped = data.model_dump(mode=\"json\", **options)\n        self.save_json(dumped, *parts, ext=ext, path_maker=path_maker, json_encoder=json_encoder, ndigits=ndigits)\n\n    def delete_pydantic(self, *parts, ext: str = \"json\", path_maker: PathMaker | None = None):\n        \"\"\"Delete a json resource relative to the current test.\"\"\"\n        self.delete(*parts, ext=ext, path_maker=path_maker)\n\n    def expect_pydantic(\n        self,\n        actual: BaseModel,\n        *parts,\n        ext: str = \"json\",\n        path_maker: PathMaker | None = None,\n        json_encoder: JsonEncoder | EllipsisType = ...,\n        ndigits: int | None | EllipsisType = ...,\n        # Optional arguments for actual.model_dump\n        context: Any = None | EllipsisType,\n        include: Any | EllipsisType = ...,\n        exclude: Any | EllipsisType = ...,\n        by_alias: bool | None | EllipsisType = ...,\n        exclude_unset: bool | EllipsisType = ...,\n        exclude_defaults: bool | EllipsisType = ...,\n        exclude_none: bool | EllipsisType = ...,\n        round_trip: bool | EllipsisType = ...,\n        serialize_as_any: bool | EllipsisType = ...,\n    ) -&gt; None:\n        \"\"\"Assert that the actual value encodes to the JSON content from resource.\"\"\"\n        # Avoid arguments that are not explicitly set to avoid pydantic version problems\n        options = _dict_without_ellipsis(\n            context=context,\n            include=include,\n            exclude=exclude,\n            by_alias=by_alias,\n            exclude_unset=exclude_unset,\n            exclude_defaults=exclude_defaults,\n            exclude_none=exclude_none,\n            round_trip=round_trip,\n            serialize_as_any=serialize_as_any,\n        )\n        actual_dumped = actual.model_dump(mode=\"json\", **options)\n        self.expect_json(\n            actual_dumped,\n            *parts,\n            ext=ext,\n            path_maker=path_maker,\n            json_encoder=json_encoder,\n            ndigits=ndigits,\n        )\n\n    # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #\n    # Pydantic TypeAdapter Resources\n\n    def load_pydantic_adapter(\n        self,\n        type_: type[T] | TypeAdapter[T],\n        *parts,\n        ext: str = \"json\",\n        path_maker: PathMaker | None = None,\n        json_loader: JsonLoader | EllipsisType = ...,\n    ) -&gt; T:\n        \"\"\"Load a resource with a pydantic TypeAdapter relative to the current test.\"\"\"\n        data = self.load_json(*parts, ext=ext, path_maker=path_maker, json_loader=json_loader)\n        adapter: TypeAdapter[T] = type_ if isinstance(type_, TypeAdapter) else TypeAdapter(type_)\n        return adapter.validate_python(data)\n\n    def save_pydantic_adapter(\n        self,\n        data: Any,\n        *parts,\n        ext: str = \"json\",\n        path_maker: PathMaker | None = None,\n        json_encoder: JsonEncoder | EllipsisType = ...,\n        ndigits: int | None | EllipsisType = ...,\n        type_: type[T] | TypeAdapter[T] | None = None,\n        # Optional arguments for adapter.dump_python\n        context: Any = None | EllipsisType,\n        include: Any | EllipsisType = ...,\n        exclude: Any | EllipsisType = ...,\n        by_alias: bool | None | EllipsisType = ...,\n        exclude_unset: bool | EllipsisType = ...,\n        exclude_defaults: bool | EllipsisType = ...,\n        exclude_none: bool | EllipsisType = ...,\n        round_trip: bool | EllipsisType = ...,\n        serialize_as_any: bool | EllipsisType = ...,\n    ) -&gt; None:\n        \"\"\"Write pydantic data to a resource relative to the current test.\"\"\"\n        type_ = type_ or type(data)\n        adapter: TypeAdapter[T] = type_ if isinstance(type_, TypeAdapter) else TypeAdapter(type_)\n        options = _dict_without_ellipsis(\n            context=context,\n            include=include,\n            exclude=exclude,\n            by_alias=by_alias,\n            exclude_unset=exclude_unset,\n            exclude_defaults=exclude_defaults,\n            exclude_none=exclude_none,\n            round_trip=round_trip,\n            serialize_as_any=serialize_as_any,\n        )\n        actual_data: T = adapter.dump_python(data, mode=\"json\", **options)\n        self.save_json(actual_data, *parts, ext=ext, path_maker=path_maker, json_encoder=json_encoder, ndigits=ndigits)\n\n    def delete_pydantic_adapter(self, *parts, ext: str = \"json\", path_maker: PathMaker | None = None):\n        \"\"\"Delete a json resource relative to the current test.\"\"\"\n        self.delete(*parts, ext=ext, path_maker=path_maker)\n\n    def expect_pydantic_adapter(\n        self,\n        actual: Any,\n        *parts,\n        ext: str = \"json\",\n        path_maker: PathMaker | None = None,\n        json_encoder: JsonEncoder | EllipsisType = ...,\n        ndigits: int | None | EllipsisType = ...,\n        type_: type[T] | TypeAdapter[T] | None = None,\n        # Optional arguments for adapter.dump_python\n        context: Any = None | EllipsisType,\n        include: Any | EllipsisType = ...,\n        exclude: Any | EllipsisType = ...,\n        by_alias: bool | None | EllipsisType = ...,\n        exclude_unset: bool | EllipsisType = ...,\n        exclude_defaults: bool | EllipsisType = ...,\n        exclude_none: bool | EllipsisType = ...,\n        round_trip: bool | EllipsisType = ...,\n        serialize_as_any: bool | EllipsisType = ...,\n    ) -&gt; None:\n        \"\"\"Assert that the type adapter encodes the actual value to the JSON content from resource. This allows us to\n        pass a context to the serializers of any objects embedded within actual.\"\"\"\n        type_ = type_ or type(actual)\n        adapter: TypeAdapter[T] = type_ if isinstance(type_, TypeAdapter) else TypeAdapter(type_)\n        options = _dict_without_ellipsis(\n            context=context,\n            include=include,\n            exclude=exclude,\n            by_alias=by_alias,\n            exclude_unset=exclude_unset,\n            exclude_defaults=exclude_defaults,\n            exclude_none=exclude_none,\n            round_trip=round_trip,\n            serialize_as_any=serialize_as_any,\n        )\n        actual_data: T = adapter.dump_python(actual, mode=\"json\", **options)\n        self.expect_json(\n            actual_data,\n            *parts,\n            ext=ext,\n            path_maker=path_maker,\n            json_encoder=json_encoder,\n            ndigits=ndigits,\n        )\n</code></pre>"},{"location":"api-resources/#pytest_respect.resources.TestResources.default","title":"<code>default = Defaults()</code>  <code>instance-attribute</code>","text":"<p>Default behaviours. They can be optionally overridden in methods that use them.</p>"},{"location":"api-resources/#pytest_respect.resources.TestResources.request","title":"<code>request = request</code>  <code>instance-attribute</code>","text":"<p>The pytest fixture request that we get context information from.</p>"},{"location":"api-resources/#pytest_respect.resources.TestResources.__init__","title":"<code>__init__(request, accept_count=0)</code>","text":"<p>Create test resources instance, usually in a function-scoped fixture.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>FixtureRequest</code> <p>The pytest fixture request object.</p> required <code>accept_count</code> <code>int</code> <p>Accept the actual results for this many mismatches before failing the test.</p> <code>0</code> Source code in <code>src/pytest_respect/resources.py</code> <pre><code>def __init__(self, request: FixtureRequest, accept_count: int = 0):\n    \"\"\"Create test resources instance, usually in a function-scoped fixture.\n\n    Args:\n        request: The pytest fixture request object.\n        accept_count: Accept the actual results for this many mismatches before failing the test.\n\n    \"\"\"\n    self.request: FixtureRequest = request\n    \"\"\"The pytest fixture request that we get context information from.\"\"\"\n\n    self._accept_count: int = accept_count\n    \"\"\"Mimatches remaining before we fail the test.\"\"\"\n\n    self.default: Defaults = Defaults()\n    \"\"\"Default behaviours. They can be optionally overridden in methods that use them.\"\"\"\n\n    self._extra_preppers: list[tuple[type | UnionType, Callable[[Any], Any]]] = []\n    \"\"\"JSON Preppers to apply after the global JSON_PREPPERS.\"\"\"\n</code></pre>"},{"location":"api-resources/#pytest_respect.resources.TestResources.add_json_prepper","title":"<code>add_json_prepper(type_, prepper)</code>","text":"<p>Register a local JSON prepper for a given type, including sub-classes.</p> <p>The prepper can return a few kinds of values:</p> <ul> <li>Simple value: encoded as-is and must be JSON serializable.</li> <li>Dict: encoded recursively but must have keys that are supported by the json_encoder in use, usually str.</li> <li>Collection: list, tuple, set, etc will be recursively encoded as a list.</li> </ul> <p>It can also raise AbortJsonPrep to skip this prepper and continue trying others.</p> Source code in <code>src/pytest_respect/resources.py</code> <pre><code>def add_json_prepper(self, type_: type | UnionType, prepper: Callable[[Any], Any]) -&gt; None:\n    \"\"\"Register a local JSON prepper for a given type, including sub-classes.\n\n    The prepper can return a few kinds of values:\n\n    - Simple value: encoded as-is and must be JSON serializable.\n    - Dict: encoded recursively but must have keys that are supported by the json_encoder in use, usually str.\n    - Collection: list, tuple, set, etc will be recursively encoded as a list.\n\n    It can also raise AbortJsonPrep to skip this prepper and continue trying others.\n    \"\"\"\n    self._extra_preppers.append((type_, prepper))\n</code></pre>"},{"location":"api-resources/#pytest_respect.resources.TestResources.data_to_json","title":"<code>data_to_json(data, json_encoder=..., ndigits=...)</code>","text":"<p>Convert data to a json string used for both expectations and save_json.</p> Source code in <code>src/pytest_respect/resources.py</code> <pre><code>def data_to_json(\n    self,\n    data: Any,\n    json_encoder: JsonEncoder | EllipsisType = ...,\n    ndigits: int | None | EllipsisType = ...,\n) -&gt; str:\n    \"\"\"Convert data to a json string used for both expectations and save_json.\"\"\"\n    ndigits = self.default._ndigits(ndigits)\n    data = prepare_for_json_encode(data, ndigits=ndigits, extra_preppers=self._extra_preppers)\n    json_encoder = self.default._json_encoder(json_encoder)\n    text = json_encoder(data)\n    if not text.endswith(\"\\n\"):\n        text += \"\\n\"\n    return text\n</code></pre>"},{"location":"api-resources/#pytest_respect.resources.TestResources.delete","title":"<code>delete(*parts, ext=None, path_maker=None)</code>","text":"<p>Delete a string resource relative to the current test.</p> Source code in <code>src/pytest_respect/resources.py</code> <pre><code>def delete(\n    self,\n    *parts,\n    ext: str | None = None,\n    path_maker: PathMaker | None = None,\n):\n    \"\"\"Delete a string resource relative to the current test.\"\"\"\n    path = self.path(*parts, ext=ext, path_maker=path_maker)\n    path.unlink(missing_ok=True)\n</code></pre>"},{"location":"api-resources/#pytest_respect.resources.TestResources.delete_json","title":"<code>delete_json(*parts, ext='json', path_maker=None)</code>","text":"<p>Delete a json resource relative to the current test.</p> Source code in <code>src/pytest_respect/resources.py</code> <pre><code>def delete_json(\n    self,\n    *parts,\n    ext: str = \"json\",\n    path_maker: PathMaker | None = None,\n):\n    \"\"\"Delete a json resource relative to the current test.\"\"\"\n    self.delete(*parts, ext=ext, path_maker=path_maker)\n</code></pre>"},{"location":"api-resources/#pytest_respect.resources.TestResources.delete_pydantic","title":"<code>delete_pydantic(*parts, ext='json', path_maker=None)</code>","text":"<p>Delete a json resource relative to the current test.</p> Source code in <code>src/pytest_respect/resources.py</code> <pre><code>def delete_pydantic(self, *parts, ext: str = \"json\", path_maker: PathMaker | None = None):\n    \"\"\"Delete a json resource relative to the current test.\"\"\"\n    self.delete(*parts, ext=ext, path_maker=path_maker)\n</code></pre>"},{"location":"api-resources/#pytest_respect.resources.TestResources.delete_pydantic_adapter","title":"<code>delete_pydantic_adapter(*parts, ext='json', path_maker=None)</code>","text":"<p>Delete a json resource relative to the current test.</p> Source code in <code>src/pytest_respect/resources.py</code> <pre><code>def delete_pydantic_adapter(self, *parts, ext: str = \"json\", path_maker: PathMaker | None = None):\n    \"\"\"Delete a json resource relative to the current test.\"\"\"\n    self.delete(*parts, ext=ext, path_maker=path_maker)\n</code></pre>"},{"location":"api-resources/#pytest_respect.resources.TestResources.delete_text","title":"<code>delete_text(*parts, ext='txt', path_maker=None)</code>","text":"<p>Delete a json resource relative to the current test.</p> Source code in <code>src/pytest_respect/resources.py</code> <pre><code>def delete_text(\n    self,\n    *parts,\n    ext: str = \"txt\",\n    path_maker: PathMaker | None = None,\n):\n    \"\"\"Delete a json resource relative to the current test.\"\"\"\n    self.delete(*parts, ext=ext, path_maker=path_maker)\n</code></pre>"},{"location":"api-resources/#pytest_respect.resources.TestResources.dir","title":"<code>dir(path_maker=None)</code>","text":"<p>Directory for resources belonging to the test.</p> <p>Parameters:</p> Name Type Description Default <code>path_maker</code> <code>PathMaker | None</code> <p>Function to turn test co-ordinates into a directory and partial file-name for the resource. The file part will be ignored.</p> <code>None</code> Source code in <code>src/pytest_respect/resources.py</code> <pre><code>def dir(self, path_maker: PathMaker | None = None) -&gt; Path:\n    \"\"\"Directory for resources belonging to the test.\n\n    Args:\n        path_maker: Function to turn test co-ordinates into a directory and partial\n            file-name for the resource. The file part will be ignored.\n\n    \"\"\"\n    path_maker = self.default._path_maker(path_maker)\n    test_file = Path(self.request.node.fspath)\n    test_class: type | None = self.request.node.cls\n\n    dir_path, base_name = path_maker(\n        test_dir=test_file.parent,\n        test_file_name=test_file.name.rsplit(\".\", 1)[0],\n        test_class_name=test_class.__name__ if test_class else None,\n        test_name=self.request.node.originalname,\n    )\n\n    return dir_path\n</code></pre>"},{"location":"api-resources/#pytest_respect.resources.TestResources.expect_json","title":"<code>expect_json(actual, *parts, ext='json', path_maker=None, json_encoder=..., ndigits=...)</code>","text":"<p>Assert that the actual value encodes to the JSON content from resource.</p> Source code in <code>src/pytest_respect/resources.py</code> <pre><code>def expect_json(\n    self,\n    actual: Any,\n    *parts,\n    ext: str = \"json\",\n    path_maker: PathMaker | None = None,\n    json_encoder: JsonEncoder | EllipsisType = ...,\n    ndigits: int | None | EllipsisType = ...,\n) -&gt; None:\n    \"\"\"Assert that the actual value encodes to the JSON content from resource.\"\"\"\n    actual_text = self.data_to_json(actual, json_encoder=json_encoder, ndigits=ndigits)\n    self.expect_text(\n        actual_text,\n        *parts,\n        ext=ext,\n        path_maker=path_maker,\n    )\n</code></pre>"},{"location":"api-resources/#pytest_respect.resources.TestResources.expect_pydantic","title":"<code>expect_pydantic(actual, *parts, ext='json', path_maker=None, json_encoder=..., ndigits=..., context=None | EllipsisType, include=..., exclude=..., by_alias=..., exclude_unset=..., exclude_defaults=..., exclude_none=..., round_trip=..., serialize_as_any=...)</code>","text":"<p>Assert that the actual value encodes to the JSON content from resource.</p> Source code in <code>src/pytest_respect/resources.py</code> <pre><code>def expect_pydantic(\n    self,\n    actual: BaseModel,\n    *parts,\n    ext: str = \"json\",\n    path_maker: PathMaker | None = None,\n    json_encoder: JsonEncoder | EllipsisType = ...,\n    ndigits: int | None | EllipsisType = ...,\n    # Optional arguments for actual.model_dump\n    context: Any = None | EllipsisType,\n    include: Any | EllipsisType = ...,\n    exclude: Any | EllipsisType = ...,\n    by_alias: bool | None | EllipsisType = ...,\n    exclude_unset: bool | EllipsisType = ...,\n    exclude_defaults: bool | EllipsisType = ...,\n    exclude_none: bool | EllipsisType = ...,\n    round_trip: bool | EllipsisType = ...,\n    serialize_as_any: bool | EllipsisType = ...,\n) -&gt; None:\n    \"\"\"Assert that the actual value encodes to the JSON content from resource.\"\"\"\n    # Avoid arguments that are not explicitly set to avoid pydantic version problems\n    options = _dict_without_ellipsis(\n        context=context,\n        include=include,\n        exclude=exclude,\n        by_alias=by_alias,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n        round_trip=round_trip,\n        serialize_as_any=serialize_as_any,\n    )\n    actual_dumped = actual.model_dump(mode=\"json\", **options)\n    self.expect_json(\n        actual_dumped,\n        *parts,\n        ext=ext,\n        path_maker=path_maker,\n        json_encoder=json_encoder,\n        ndigits=ndigits,\n    )\n</code></pre>"},{"location":"api-resources/#pytest_respect.resources.TestResources.expect_pydantic_adapter","title":"<code>expect_pydantic_adapter(actual, *parts, ext='json', path_maker=None, json_encoder=..., ndigits=..., type_=None, context=None | EllipsisType, include=..., exclude=..., by_alias=..., exclude_unset=..., exclude_defaults=..., exclude_none=..., round_trip=..., serialize_as_any=...)</code>","text":"<p>Assert that the type adapter encodes the actual value to the JSON content from resource. This allows us to pass a context to the serializers of any objects embedded within actual.</p> Source code in <code>src/pytest_respect/resources.py</code> <pre><code>def expect_pydantic_adapter(\n    self,\n    actual: Any,\n    *parts,\n    ext: str = \"json\",\n    path_maker: PathMaker | None = None,\n    json_encoder: JsonEncoder | EllipsisType = ...,\n    ndigits: int | None | EllipsisType = ...,\n    type_: type[T] | TypeAdapter[T] | None = None,\n    # Optional arguments for adapter.dump_python\n    context: Any = None | EllipsisType,\n    include: Any | EllipsisType = ...,\n    exclude: Any | EllipsisType = ...,\n    by_alias: bool | None | EllipsisType = ...,\n    exclude_unset: bool | EllipsisType = ...,\n    exclude_defaults: bool | EllipsisType = ...,\n    exclude_none: bool | EllipsisType = ...,\n    round_trip: bool | EllipsisType = ...,\n    serialize_as_any: bool | EllipsisType = ...,\n) -&gt; None:\n    \"\"\"Assert that the type adapter encodes the actual value to the JSON content from resource. This allows us to\n    pass a context to the serializers of any objects embedded within actual.\"\"\"\n    type_ = type_ or type(actual)\n    adapter: TypeAdapter[T] = type_ if isinstance(type_, TypeAdapter) else TypeAdapter(type_)\n    options = _dict_without_ellipsis(\n        context=context,\n        include=include,\n        exclude=exclude,\n        by_alias=by_alias,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n        round_trip=round_trip,\n        serialize_as_any=serialize_as_any,\n    )\n    actual_data: T = adapter.dump_python(actual, mode=\"json\", **options)\n    self.expect_json(\n        actual_data,\n        *parts,\n        ext=ext,\n        path_maker=path_maker,\n        json_encoder=json_encoder,\n        ndigits=ndigits,\n    )\n</code></pre>"},{"location":"api-resources/#pytest_respect.resources.TestResources.expect_text","title":"<code>expect_text(actual, *parts, ext='txt', path_maker=None)</code>","text":"<p>Assert that the actual value matches the content from resource.</p> Source code in <code>src/pytest_respect/resources.py</code> <pre><code>def expect_text(\n    self,\n    actual: str,\n    *parts,\n    ext: str = \"txt\",\n    path_maker: PathMaker | None = None,\n) -&gt; None:\n    \"\"\"Assert that the actual value matches the content from resource.\"\"\"\n    expected_path = self.path(*parts, ext=ext, path_maker=path_maker)\n    actual_path = self.path(*parts, \"actual\", ext=ext, path_maker=path_maker)\n\n    if not expected_path.is_file():\n        expected_path.parent.mkdir(parents=False, exist_ok=True)\n        if self._accept_one():\n            expected_path.write_text(actual)\n            print(f\"A new expectation file was written to {expected_path}.\")\n            actual_path.unlink(missing_ok=True)\n        else:\n            actual_path.write_text(actual)\n            raise AssertionError(\n                f\"The expectation file was not found at {expected_path}. \"\n                f\"The actual value has been written to {actual_path}.\"\n            )\n\n    expected = expected_path.read_text()\n\n    try:\n        assert actual == expected, (\n            f\"The actual value did not match the content of {expected_path}. \"\n            f\"It has been written to {actual_path} for comparison.\"\n        )\n        if actual_path.exists():\n            actual_path.unlink(missing_ok=True)\n            print(\"removing matching actual file\", actual_path)\n    except AssertionError:\n        if self._accept_one():\n            print(f\"The expectation file was updated at {expected_path}.\")\n            expected_path.write_text(actual)\n            actual_path.unlink(missing_ok=True)\n        else:\n            actual_path.write_text(actual)\n            raise\n</code></pre>"},{"location":"api-resources/#pytest_respect.resources.TestResources.list","title":"<code>list(include='*', *, exclude=tuple(), path_maker=None, strip_ext=False)</code>","text":"<p>List the names of the resources in the folder.</p> <p>Parameters:</p> Name Type Description Default <code>include</code> <code>str | Sequence[str]</code> <p>one or more glob patterns for filenames to include</p> <code>'*'</code> <code>exclude</code> <code>str | Sequence[str]</code> <p>zero or more glob patterns for filenames to exclude</p> <code>tuple()</code> <code>path_maker</code> <code>PathMaker | None</code> <p>Function to turn test co-ordinates into a directory and partial file-name for the resource. The file part will be ignored.</p> <code>None</code> <p>strip_ext: Whether to strip extension from listed resource file names. If     True or False then strip all or no extensions from last dot.     If string, then strip only that string from the ends of file names. A     strip_ext string must include the dot (if wanted) to allow stripping     suffixes such as <code>__bad.json</code></p> Source code in <code>src/pytest_respect/resources.py</code> <pre><code>def list(\n    self,\n    include: str | Sequence[str] = \"*\",\n    *,\n    exclude: str | Sequence[str] = tuple(),\n    path_maker: PathMaker | None = None,\n    strip_ext: str | bool = False,\n) -&gt; list[str]:\n    \"\"\"List the names of the resources in the folder.\n\n    Args:\n        include: one or more glob patterns for filenames to include\n        exclude: zero or more glob patterns for filenames to exclude\n        path_maker: Function to turn test co-ordinates into a directory and partial\n            file-name for the resource. The file part will be ignored.\n    strip_ext: Whether to strip extension from listed resource file names. If\n        True or False then strip all or no extensions from last dot.\n        If string, then strip only that string from the ends of file names. A\n        strip_ext string must include the dot (if wanted) to allow stripping\n        suffixes such as `__bad.json`\n\n    \"\"\"\n    dir: Path = self.dir(path_maker)\n    return list_dir(dir, include, exclude=exclude, strip_ext=strip_ext)\n</code></pre>"},{"location":"api-resources/#pytest_respect.resources.TestResources.load_json","title":"<code>load_json(*parts, ext='json', path_maker=None, json_loader=...)</code>","text":"<p>Load a json resource relative to the current test.</p> Source code in <code>src/pytest_respect/resources.py</code> <pre><code>def load_json(\n    self,\n    *parts,\n    ext: str = \"json\",\n    path_maker: PathMaker | None = None,\n    json_loader: JsonLoader | EllipsisType = ...,\n) -&gt; Any:\n    \"\"\"Load a json resource relative to the current test.\"\"\"\n    path = self.path(*parts, ext=ext, path_maker=path_maker)\n    try:\n        text = path.read_text()\n        json_loader = self.default._json_loader(json_loader)\n        return json_loader(text)\n    except Exception as e:\n        raise ValueError(f\"Failed to load JSON resource {path}: {repr(e)}\") from e\n</code></pre>"},{"location":"api-resources/#pytest_respect.resources.TestResources.load_pydantic","title":"<code>load_pydantic(model_class, *parts, ext='json', path_maker=None, json_loader=...)</code>","text":"<p>Load a pydantic resource relative to the current test.</p> Source code in <code>src/pytest_respect/resources.py</code> <pre><code>def load_pydantic(\n    self,\n    model_class: type[PMT],\n    *parts,\n    ext: str = \"json\",\n    path_maker: PathMaker | None = None,\n    json_loader: JsonLoader | EllipsisType = ...,\n) -&gt; PMT:\n    \"\"\"Load a pydantic resource relative to the current test.\"\"\"\n    data = self.load_json(*parts, ext=ext, path_maker=path_maker, json_loader=json_loader)\n    return model_class.model_validate(data)\n</code></pre>"},{"location":"api-resources/#pytest_respect.resources.TestResources.load_pydantic_adapter","title":"<code>load_pydantic_adapter(type_, *parts, ext='json', path_maker=None, json_loader=...)</code>","text":"<p>Load a resource with a pydantic TypeAdapter relative to the current test.</p> Source code in <code>src/pytest_respect/resources.py</code> <pre><code>def load_pydantic_adapter(\n    self,\n    type_: type[T] | TypeAdapter[T],\n    *parts,\n    ext: str = \"json\",\n    path_maker: PathMaker | None = None,\n    json_loader: JsonLoader | EllipsisType = ...,\n) -&gt; T:\n    \"\"\"Load a resource with a pydantic TypeAdapter relative to the current test.\"\"\"\n    data = self.load_json(*parts, ext=ext, path_maker=path_maker, json_loader=json_loader)\n    adapter: TypeAdapter[T] = type_ if isinstance(type_, TypeAdapter) else TypeAdapter(type_)\n    return adapter.validate_python(data)\n</code></pre>"},{"location":"api-resources/#pytest_respect.resources.TestResources.load_text","title":"<code>load_text(*parts, ext='txt', path_maker=None)</code>","text":"<p>Load a string resource relative to the current test.</p> Source code in <code>src/pytest_respect/resources.py</code> <pre><code>def load_text(\n    self,\n    *parts,\n    ext: str = \"txt\",\n    path_maker: PathMaker | None = None,\n) -&gt; str:\n    \"\"\"Load a string resource relative to the current test.\"\"\"\n    path = self.path(*parts, ext=ext, path_maker=path_maker)\n    return path.read_text()\n</code></pre>"},{"location":"api-resources/#pytest_respect.resources.TestResources.path","title":"<code>path(*parts, ext=None, path_maker=None)</code>","text":"<p>Path to a resource file within this test file/class's directory.</p> <p>Parameters:</p> Name Type Description Default <code>parts</code> <code>Any</code> <p>Concatenate these parts to the function name, with __ separator to make file-name.</p> <code>()</code> <code>ext</code> <code>str | None</code> <p>Add this extension to the file-name if not already present. Defaults to nothing which can be appropriate if we knot that the last <code>part</code> already has an extension.</p> <code>None</code> <code>path_maker</code> <code>PathMaker | None</code> <p>Function to turn test co-ordinates into a directory and partial file-name for the resource. Defaults to one which uses the test file (and class if present) for the dir and the test function for the file.</p> <code>None</code> Source code in <code>src/pytest_respect/resources.py</code> <pre><code>def path(\n    self,\n    *parts: Any,\n    ext: str | None = None,\n    path_maker: PathMaker | None = None,\n) -&gt; Path:\n    \"\"\"Path to a resource file within this test file/class's directory.\n\n    Args:\n        parts: Concatenate these parts to the function name, with __ separator to\n            make file-name.\n        ext: Add this extension to the file-name if not already present. Defaults\n            to nothing which can be appropriate if we knot that the last ``part``\n            already has an extension.\n        path_maker: Function to turn test co-ordinates into a directory and partial\n            file-name for the resource. Defaults to one which uses the test file\n            (and class if present) for the dir and the test function for the file.\n\n    \"\"\"\n    path_maker = self.default._path_maker(path_maker)\n    test_file = Path(self.request.node.fspath)\n    test_class: type | None = self.request.node.cls\n\n    dir_path, base_name = path_maker(\n        test_dir=test_file.parent,\n        test_file_name=test_file.name.rsplit(\".\", 1)[0],\n        test_class_name=test_class.__name__ if test_class else None,\n        test_name=self.request.node.originalname,\n    )\n\n    name_parts: list[str] = []\n    if base_name:\n        name_parts.append(base_name)\n    name_parts.extend(map(str, parts))\n    if not name_parts:\n        # If we have not file-name parts from anywhere, then fall back to \"data\"\n        name_parts = [\"data\"]\n\n    name = \"__\".join(name_parts)\n    if ext and not name.endswith(f\".{ext}\"):\n        name = f\"{name}.{ext}\"\n    return dir_path / name\n</code></pre>"},{"location":"api-resources/#pytest_respect.resources.TestResources.pm_class","title":"<code>pm_class(test_dir, test_file_name, test_class_name, test_name)</code>  <code>staticmethod</code>","text":"<p>PathMaker to build directory from test_file and class if present, and file-name from test method.</p> <p>This is the default method for constructing resource paths.</p> <ul> <li><code>&lt;dir&gt;/test_file/test_function.&lt;ext&gt;</code></li> <li><code>&lt;dir&gt;/test_file__TestClass/test_method.&lt;ext&gt;</code></li> </ul> Source code in <code>src/pytest_respect/resources.py</code> <pre><code>@staticmethod\ndef pm_class(test_dir: Path, test_file_name: str, test_class_name: str | None, test_name: str) -&gt; PathParts:\n    \"\"\"PathMaker to build directory from test_file and class if present, and file-name from test method.\n\n    This is the default method for constructing resource paths.\n\n    - ``&lt;dir&gt;/test_file/test_function.&lt;ext&gt;``\n    - ``&lt;dir&gt;/test_file__TestClass/test_method.&lt;ext&gt;``\n    \"\"\"\n    if test_class_name:\n        dir = test_dir / f\"{test_file_name}__{test_class_name}\"\n    else:\n        dir = test_dir / test_file_name\n    return dir, test_name\n</code></pre>"},{"location":"api-resources/#pytest_respect.resources.TestResources.pm_dir","title":"<code>pm_dir(test_dir, test_file_name, test_class_name, test_name)</code>  <code>staticmethod</code>","text":"<p>PathMaker to use \"resources\" for directory and build file-name from test file, test class if present and test function.</p> <ul> <li><code>&lt;dir&gt;/resources/test_file__test_function.&lt;ext&gt;</code></li> <li><code>&lt;dir&gt;/resources/test_file__TestClass__test_method.&lt;ext&gt;</code></li> </ul> Source code in <code>src/pytest_respect/resources.py</code> <pre><code>@staticmethod\ndef pm_dir(test_dir: Path, test_file_name: str, test_class_name: str | None, test_name: str) -&gt; PathParts:\n    \"\"\"PathMaker to use \"resources\" for directory and build file-name from test file, test class if present and\n    test function.\n\n    - ``&lt;dir&gt;/resources/test_file__test_function.&lt;ext&gt;``\n    - ``&lt;dir&gt;/resources/test_file__TestClass__test_method.&lt;ext&gt;``\n    \"\"\"\n    path_maker = TestResources.pm_dir_named(DEFAULT_RESOURCES_DIR)\n    return path_maker(test_dir, test_file_name, test_class_name, test_name)\n</code></pre>"},{"location":"api-resources/#pytest_respect.resources.TestResources.pm_dir_named","title":"<code>pm_dir_named(dir_name=DEFAULT_RESOURCES_DIR)</code>  <code>staticmethod</code>","text":"<p>PathMaker to use the given name for directory and build file-name from test file, test class if present and test function.</p> <ul> <li><code>&lt;dir&gt;/&lt;dir_name&gt;/test_file__test_function.&lt;ext&gt;</code></li> <li><code>&lt;dir&gt;/&lt;dir_name&gt;/test_file__TestClass__test_method.&lt;ext&gt;</code></li> </ul> Source code in <code>src/pytest_respect/resources.py</code> <pre><code>@staticmethod\ndef pm_dir_named(dir_name: str = DEFAULT_RESOURCES_DIR) -&gt; PathMaker:\n    \"\"\"PathMaker to use the given name for directory and build file-name from test file, test class if present and\n    test function.\n\n    - ``&lt;dir&gt;/&lt;dir_name&gt;/test_file__test_function.&lt;ext&gt;``\n    - ``&lt;dir&gt;/&lt;dir_name&gt;/test_file__TestClass__test_method.&lt;ext&gt;``\n    \"\"\"\n\n    def path_from_dir(\n        test_dir: Path,\n        test_file_name: str,\n        test_class_name: str | None,\n        test_name: str,\n    ) -&gt; PathParts:\n        if test_class_name:\n            file = f\"{test_file_name}__{test_class_name}__{test_name}\"\n        else:\n            file = f\"{test_file_name}__{test_name}\"\n        return test_dir / dir_name, file\n\n    return path_from_dir\n</code></pre>"},{"location":"api-resources/#pytest_respect.resources.TestResources.pm_file","title":"<code>pm_file(test_dir, test_file_name, test_class_name, test_name)</code>  <code>staticmethod</code>","text":"<p>PathMaker to build directory from test_file and file-name from test class if present, and test method.</p> <ul> <li><code>&lt;dir&gt;/test_file/test_function.&lt;ext&gt;</code></li> <li><code>&lt;dir&gt;/test_file/TestClass__test_method.&lt;ext&gt;</code></li> </ul> Source code in <code>src/pytest_respect/resources.py</code> <pre><code>@staticmethod\ndef pm_file(test_dir: Path, test_file_name: str, test_class_name: str | None, test_name: str) -&gt; PathParts:\n    \"\"\"PathMaker to build directory from test_file and file-name from test class if present, and test method.\n\n    - ``&lt;dir&gt;/test_file/test_function.&lt;ext&gt;``\n    - ``&lt;dir&gt;/test_file/TestClass__test_method.&lt;ext&gt;``\n    \"\"\"\n    if test_class_name:\n        file = f\"{test_class_name}__{test_name}\"\n    else:\n        file = test_name\n    return test_dir / test_file_name, file\n</code></pre>"},{"location":"api-resources/#pytest_respect.resources.TestResources.pm_function","title":"<code>pm_function(test_dir, test_file_name, test_class_name, test_name)</code>  <code>staticmethod</code>","text":"<p>PathMaker to build directory from test_file, class if present, and function. No contribution is made to the file name.</p> <ul> <li><code>&lt;dir&gt;/test_file__test_function/data.&lt;ext&gt;</code></li> <li><code>&lt;dir&gt;/test_file__TestClass__test_method/data.&lt;ext&gt;</code></li> </ul> Source code in <code>src/pytest_respect/resources.py</code> <pre><code>@staticmethod\ndef pm_function(test_dir: Path, test_file_name: str, test_class_name: str | None, test_name: str) -&gt; PathParts:\n    \"\"\"PathMaker to build directory from test_file, class if present, and function. No contribution is made to the\n    file name.\n\n    - ``&lt;dir&gt;/test_file__test_function/data.&lt;ext&gt;``\n    - ``&lt;dir&gt;/test_file__TestClass__test_method/data.&lt;ext&gt;``\n    \"\"\"\n    if test_class_name:\n        dir = test_dir / f\"{test_file_name}__{test_class_name}__{test_name}\"\n    else:\n        dir = test_dir / f\"{test_file_name}__{test_name}\"\n\n    return dir, None\n</code></pre>"},{"location":"api-resources/#pytest_respect.resources.TestResources.pm_only_class","title":"<code>pm_only_class(test_dir, test_file_name, test_class_name, test_name)</code>  <code>staticmethod</code>","text":"<p>PathMaker to build directory from test_file and class if present and contribute nothing to the file-name</p> <ul> <li><code>&lt;dir&gt;/test_file__TestClass/data.&lt;ext&gt;</code></li> <li><code>&lt;dir&gt;/test_file/data.&lt;ext&gt;</code></li> </ul> Source code in <code>src/pytest_respect/resources.py</code> <pre><code>@staticmethod\ndef pm_only_class(test_dir: Path, test_file_name: str, test_class_name: str | None, test_name: str) -&gt; PathParts:\n    \"\"\"PathMaker to build directory from test_file and class if present and contribute nothing to the file-name\n\n    - ``&lt;dir&gt;/test_file__TestClass/data.&lt;ext&gt;``\n    - ``&lt;dir&gt;/test_file/data.&lt;ext&gt;``\n    \"\"\"\n    if test_class_name:\n        dir = test_dir / f\"{test_file_name}__{test_class_name}\"\n    else:\n        dir = test_dir / test_file_name\n    return dir, None\n</code></pre>"},{"location":"api-resources/#pytest_respect.resources.TestResources.pm_only_dir","title":"<code>pm_only_dir(test_dir, test_file_name, test_class_name=None, test_name=None)</code>  <code>staticmethod</code>","text":"<p>Use \"resources\" for directory and nothing for the file-name.</p> Source code in <code>src/pytest_respect/resources.py</code> <pre><code>@staticmethod\ndef pm_only_dir(\n    test_dir: Path,\n    test_file_name: str,\n    test_class_name: str | None = None,\n    test_name: str | None = None,\n) -&gt; PathParts:\n    \"\"\"Use \"resources\" for directory and nothing for the file-name.\"\"\"\n    return test_dir / DEFAULT_RESOURCES_DIR, None\n</code></pre>"},{"location":"api-resources/#pytest_respect.resources.TestResources.pm_only_dir_named","title":"<code>pm_only_dir_named(dir_name=DEFAULT_RESOURCES_DIR)</code>  <code>staticmethod</code>","text":"<p>Use the given name for directory nothing for the file-name.</p> Source code in <code>src/pytest_respect/resources.py</code> <pre><code>@staticmethod\ndef pm_only_dir_named(dir_name: str = DEFAULT_RESOURCES_DIR) -&gt; PathMaker:\n    \"\"\"Use the given name for directory nothing for the file-name.\"\"\"\n\n    def path_from_dir(\n        test_dir: Path,\n        test_file_name: str,\n        test_class_name: str | None,\n        test_name: str,\n    ) -&gt; PathParts:\n        return test_dir / dir_name, None\n\n    return path_from_dir\n</code></pre>"},{"location":"api-resources/#pytest_respect.resources.TestResources.pm_only_file","title":"<code>pm_only_file(test_dir, test_file_name, test_class_name=None, test_name=None)</code>  <code>staticmethod</code>","text":"<p>PathMaker to build directory from test_file and contribute to the file-name.</p> <ul> <li><code>&lt;dir&gt;/test_file/data.&lt;ext&gt;</code></li> </ul> Source code in <code>src/pytest_respect/resources.py</code> <pre><code>@staticmethod\ndef pm_only_file(\n    test_dir: Path,\n    test_file_name: str,\n    test_class_name: str | None = None,\n    test_name: str | None = None,\n) -&gt; tuple[Path, str | None]:\n    \"\"\"PathMaker to build directory from test_file and contribute to the file-name.\n\n    - ``&lt;dir&gt;/test_file/data.&lt;ext&gt;``\n    \"\"\"\n    return test_dir / test_file_name, None\n</code></pre>"},{"location":"api-resources/#pytest_respect.resources.TestResources.save_json","title":"<code>save_json(data, *parts, ext='json', path_maker=None, json_encoder=..., ndigits=...)</code>","text":"<p>Write JSON data to a resource relative to the current test.</p> Source code in <code>src/pytest_respect/resources.py</code> <pre><code>def save_json(\n    self,\n    data: Any,\n    *parts,\n    ext: str = \"json\",\n    path_maker: PathMaker | None = None,\n    json_encoder: JsonEncoder | EllipsisType = ...,\n    ndigits: int | None | EllipsisType = ...,\n) -&gt; None:\n    \"\"\"Write JSON data to a resource relative to the current test.\"\"\"\n    text = self.data_to_json(data, json_encoder=json_encoder, ndigits=ndigits)\n    self.save_text(text, *parts, ext=ext, path_maker=path_maker)\n</code></pre>"},{"location":"api-resources/#pytest_respect.resources.TestResources.save_pydantic","title":"<code>save_pydantic(data, *parts, ext='json', path_maker=None, json_encoder=..., ndigits=..., context=None | EllipsisType, include=..., exclude=..., by_alias=..., exclude_unset=..., exclude_defaults=..., exclude_none=..., round_trip=..., serialize_as_any=...)</code>","text":"<p>Write pydantic data to a resource relative to the current test.</p> Source code in <code>src/pytest_respect/resources.py</code> <pre><code>def save_pydantic(\n    self,\n    data: Any,\n    *parts,\n    ext: str = \"json\",\n    path_maker: PathMaker | None = None,\n    json_encoder: JsonEncoder | EllipsisType = ...,\n    ndigits: int | None | EllipsisType = ...,\n    # Optional arguments for data.model_dump\n    context: Any = None | EllipsisType,\n    include: Any | EllipsisType = ...,\n    exclude: Any | EllipsisType = ...,\n    by_alias: bool | None | EllipsisType = ...,\n    exclude_unset: bool | EllipsisType = ...,\n    exclude_defaults: bool | EllipsisType = ...,\n    exclude_none: bool | EllipsisType = ...,\n    round_trip: bool | EllipsisType = ...,\n    serialize_as_any: bool | EllipsisType = ...,\n) -&gt; None:\n    \"\"\"Write pydantic data to a resource relative to the current test.\"\"\"\n    # Avoid arguments that are not explicitly set to avoid pydantic version problems\n    options = _dict_without_ellipsis(\n        context=context,\n        include=include,\n        exclude=exclude,\n        by_alias=by_alias,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n        round_trip=round_trip,\n        serialize_as_any=serialize_as_any,\n    )\n    dumped = data.model_dump(mode=\"json\", **options)\n    self.save_json(dumped, *parts, ext=ext, path_maker=path_maker, json_encoder=json_encoder, ndigits=ndigits)\n</code></pre>"},{"location":"api-resources/#pytest_respect.resources.TestResources.save_pydantic_adapter","title":"<code>save_pydantic_adapter(data, *parts, ext='json', path_maker=None, json_encoder=..., ndigits=..., type_=None, context=None | EllipsisType, include=..., exclude=..., by_alias=..., exclude_unset=..., exclude_defaults=..., exclude_none=..., round_trip=..., serialize_as_any=...)</code>","text":"<p>Write pydantic data to a resource relative to the current test.</p> Source code in <code>src/pytest_respect/resources.py</code> <pre><code>def save_pydantic_adapter(\n    self,\n    data: Any,\n    *parts,\n    ext: str = \"json\",\n    path_maker: PathMaker | None = None,\n    json_encoder: JsonEncoder | EllipsisType = ...,\n    ndigits: int | None | EllipsisType = ...,\n    type_: type[T] | TypeAdapter[T] | None = None,\n    # Optional arguments for adapter.dump_python\n    context: Any = None | EllipsisType,\n    include: Any | EllipsisType = ...,\n    exclude: Any | EllipsisType = ...,\n    by_alias: bool | None | EllipsisType = ...,\n    exclude_unset: bool | EllipsisType = ...,\n    exclude_defaults: bool | EllipsisType = ...,\n    exclude_none: bool | EllipsisType = ...,\n    round_trip: bool | EllipsisType = ...,\n    serialize_as_any: bool | EllipsisType = ...,\n) -&gt; None:\n    \"\"\"Write pydantic data to a resource relative to the current test.\"\"\"\n    type_ = type_ or type(data)\n    adapter: TypeAdapter[T] = type_ if isinstance(type_, TypeAdapter) else TypeAdapter(type_)\n    options = _dict_without_ellipsis(\n        context=context,\n        include=include,\n        exclude=exclude,\n        by_alias=by_alias,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n        round_trip=round_trip,\n        serialize_as_any=serialize_as_any,\n    )\n    actual_data: T = adapter.dump_python(data, mode=\"json\", **options)\n    self.save_json(actual_data, *parts, ext=ext, path_maker=path_maker, json_encoder=json_encoder, ndigits=ndigits)\n</code></pre>"},{"location":"api-resources/#pytest_respect.resources.TestResources.save_text","title":"<code>save_text(text, *parts, ext='txt', path_maker=None)</code>","text":"<p>Write a string to a resource relative to the current test.</p> Source code in <code>src/pytest_respect/resources.py</code> <pre><code>def save_text(\n    self,\n    text: str,\n    *parts,\n    ext: str = \"txt\",\n    path_maker: PathMaker | None = None,\n) -&gt; None:\n    \"\"\"Write a string to a resource relative to the current test.\"\"\"\n    path = self.path(*parts, ext=ext, path_maker=path_maker)\n    if not path.parent.exists():\n        path.parent.mkdir(parents=True, exist_ok=True)\n    print(f\"write {len(text)} chars to {path}\")\n    path.parent.mkdir(parents=False, exist_ok=True)\n    path.write_text(text)\n</code></pre>"},{"location":"api-resources/#pytest_respect.resources.list_dir","title":"<code>list_dir(dir, include='*', *, exclude=tuple(), strip_ext=False)</code>","text":"<p>List the names of the files in the directory, including and excluding globs.</p> Source code in <code>src/pytest_respect/resources.py</code> <pre><code>def list_dir(\n    dir: Path,\n    include: str | Sequence[str] = \"*\",\n    *,\n    exclude: str | Sequence[str] = tuple(),\n    strip_ext: str | bool = False,\n) -&gt; list[str]:\n    \"\"\"List the names of the files in the directory, including and excluding globs.\"\"\"\n    if isinstance(include, str):\n        include = [include]\n    if isinstance(exclude, str):\n        exclude = [exclude]\n\n    names: set[str] = set()\n    for inc in include:\n        names.update(path.name for path in dir.glob(inc))\n    for exc in exclude:\n        names = {name for name in names if not fnmatch.fnmatch(name, exc)}\n    name_list = sorted(names)\n    name_list = strip_extensions(name_list, strip_ext=strip_ext)\n    return name_list\n</code></pre>"},{"location":"api-resources/#pytest_respect.resources.list_resources","title":"<code>list_resources(include='*', *, exclude=tuple(), path_maker=None, strip_ext=False)</code>","text":"<p>Static version of TestResources.list method which can be used for parametric tests.</p> <p>This version does not have access to a FixtureRequest object so we use the directory of the calling module instead. We have no test class or test function to pass to the path_maker and we use only the directory from its return value.</p> <p>Parametric Test Example:</p> <pre><code>@pytest.mark.parametrize(\"curve_name\", list_resources(\"power_curve_*.json\")\ndef test_power_curve(resources, curve_name):\n   curve = resources.load_pydantic(PowerCurve, curve_name)\n   assert len(curve.points) &gt;= 2\n</code></pre> <p>Parametric Fixture Example:</p> <pre><code>@pytest.fixture(params=list_resources(\"power_curve_*.json\", exclude=[\"*__actual*\"], strip_ext=\".json\"))\ndef each_power_curve(request, resources) -&gt; PowerCurve:\n   return resources.load_pydantic(PowerCurve, request.param)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>include</code> <code>str | Sequence[str]</code> <p>one or more glob patterns for filenames to include</p> <code>'*'</code> <code>exclude</code> <code>str | Sequence[str]</code> <p>zero or more glob patterns for filenames to exclude</p> <code>tuple()</code> <code>path_maker</code> <code>PathMaker | None</code> <p>Function to turn test co-ordinates into a directory to look for resources in. The default uses the test file name for the directory.</p> <code>None</code> <code>strip_ext</code> <code>str | bool</code> <p>Whether to strip extension from listed resource file names. If True or False then strip all or no extensions from last dot. If string, then strip only that string from the ends of file names. A strip_ext string must include the dot (if wanted) to allow stripping suffixes such as <code>__bad.json</code></p> <code>False</code> Source code in <code>src/pytest_respect/resources.py</code> <pre><code>def list_resources(\n    include: str | Sequence[str] = \"*\",\n    *,\n    exclude: str | Sequence[str] = tuple(),\n    path_maker: PathMaker | None = None,\n    strip_ext: str | bool = False,\n) -&gt; builtins.list[str]:\n    \"\"\"Static version of TestResources.list method which can be used for parametric tests.\n\n    This version does not have access to a FixtureRequest object so we use the directory of the calling module instead.\n    We have no test class or test function to pass to the path_maker and we use only the directory from its return\n    value.\n\n    Parametric Test Example:\n\n    ```python\n    @pytest.mark.parametrize(\"curve_name\", list_resources(\"power_curve_*.json\")\n    def test_power_curve(resources, curve_name):\n       curve = resources.load_pydantic(PowerCurve, curve_name)\n       assert len(curve.points) &gt;= 2\n    ```\n\n    Parametric Fixture Example:\n\n    ```python\n    @pytest.fixture(params=list_resources(\"power_curve_*.json\", exclude=[\"*__actual*\"], strip_ext=\".json\"))\n    def each_power_curve(request, resources) -&gt; PowerCurve:\n       return resources.load_pydantic(PowerCurve, request.param)\n    ```\n\n    Args:\n        include: one or more glob patterns for filenames to include\n        exclude: zero or more glob patterns for filenames to exclude\n        path_maker: Function to turn test co-ordinates into a directory to look for\n            resources in. The default uses the test file name for the directory.\n        strip_ext: Whether to strip extension from listed resource file names. If\n            True or False then strip all or no extensions from last dot.\n            If string, then strip only that string from the ends of file names. A\n            strip_ext string must include the dot (if wanted) to allow stripping\n            suffixes such as `__bad.json`\n\n    \"\"\"\n    if path_maker is None:\n        path_maker = TestResources.pm_only_file\n\n    calling_frame = inspect.stack()[1]\n    test_file = Path(calling_frame.filename)\n\n    dir_path, _ = path_maker(\n        test_dir=test_file.parent,\n        test_file_name=test_file.name.rsplit(\".\", 1)[0],\n        test_class_name=None,\n        test_name=\"\",\n    )\n\n    resources = list_dir(dir_path, include, exclude=exclude)\n    resources = strip_extensions(resources, strip_ext)\n    return resources\n</code></pre>"},{"location":"api-resources/#pytest_respect.resources.python_compact_json_encoder","title":"<code>python_compact_json_encoder(obj)</code>","text":"<p>Standard JSON encoder in very compact mode.</p> Source code in <code>src/pytest_respect/resources.py</code> <pre><code>def python_compact_json_encoder(obj: Any) -&gt; str:\n    \"\"\"Standard JSON encoder in very compact mode.\"\"\"\n    return json.dumps(obj, sort_keys=True, indent=None)\n</code></pre>"},{"location":"api-resources/#pytest_respect.resources.python_json_encoder","title":"<code>python_json_encoder(obj)</code>","text":"<p>Standard JSON encoder in very verbose mode.</p> Source code in <code>src/pytest_respect/resources.py</code> <pre><code>def python_json_encoder(obj: Any) -&gt; str:\n    \"\"\"Standard JSON encoder in very verbose mode.\"\"\"\n    return json.dumps(obj, sort_keys=True, indent=2)\n</code></pre>"},{"location":"api-resources/#pytest_respect.resources.python_json_loader","title":"<code>python_json_loader(text)</code>","text":"<p>Standard JSON loader.</p> Source code in <code>src/pytest_respect/resources.py</code> <pre><code>def python_json_loader(text: str) -&gt; Any:\n    \"\"\"Standard JSON loader.\"\"\"\n    return json.loads(text)\n</code></pre>"},{"location":"api-resources/#pytest_respect.resources.strip_extensions","title":"<code>strip_extensions(resources, strip_ext=False)</code>","text":"<p>Strip file extensions from a list of resources, depending on strip_ext.</p> <p>Parameters:</p> Name Type Description Default <code>resources</code> <code>Iterable[str]</code> <p>list of resources to maybe strip extensions from.</p> required <code>strip_ext</code> <code>str | bool</code> <p>Whether to strip extension from listed resource file names. If True or False then strip all or no extensions from last dot. If string, then strip only that string from the ends of file names. A strip_ext string must include the dot (if wanted) to allow stripping suffixes such as <code>__bad.json</code></p> <code>False</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>The original resources or a copy with extensions stripped.</p> Source code in <code>src/pytest_respect/resources.py</code> <pre><code>def strip_extensions(\n    resources: Iterable[str],\n    strip_ext: str | bool = False,\n) -&gt; list[str]:\n    \"\"\"Strip file extensions from a list of resources, depending on strip_ext.\n\n    Args:\n        resources: list of resources to maybe strip extensions from.\n        strip_ext: Whether to strip extension from listed resource file names. If\n            True or False then strip all or no extensions from last dot.\n            If string, then strip only that string from the ends of file names. A\n            strip_ext string must include the dot (if wanted) to allow stripping\n            suffixes such as `__bad.json`\n\n    Returns:\n        The original resources or a copy with extensions stripped.\n\n    \"\"\"\n    if strip_ext is True:\n        resources = [r.rsplit(\".\", 1)[0] for r in resources]\n    elif isinstance(strip_ext, str):\n        resources = [r.removesuffix(strip_ext) for r in resources]\n    elif not isinstance(strip_ext, list):\n        resources = list(resources)\n    return resources\n</code></pre>"},{"location":"api-utils/","title":"<code>pytest_respect.utils</code>","text":"<p>Utilities used by the <code>resources</code> fixture. Most notably holds the registry of \"perppers\" which prepare values of different types to be converted to JSON.</p>"},{"location":"api-utils/#pytest_respect.utils.AbortJsonPrep","title":"<code>AbortJsonPrep</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised by a JSON prepper to indicate that even though the argument is of the expected type, it should not be handled by this prepper and any other ones should be given the oportuinty to handle it.</p> Source code in <code>src/pytest_respect/utils.py</code> <pre><code>class AbortJsonPrep(Exception):  # noqa: N818\n    \"\"\"Raised by a JSON prepper to indicate that even though the argument is of the expected type, it should not be\n    handled by this prepper and any other ones should be given the oportuinty to handle it.\"\"\"\n</code></pre>"},{"location":"api-utils/#pytest_respect.utils.add_json_prepper","title":"<code>add_json_prepper(type_, prepper)</code>","text":"<p>Register a global JSON prepper for a given type, including sub-classes.</p> <p>The prepper can return a few kinds of values: - Simple value: encoded as-is and must be JSON serializable. - Dict: encoded recursively but must have keys that are supported by the json_encoder use, which is usually str. - Collection: list, tuple, set, etc will be recursively encoded as a list.</p> <p>It can also raise AbortJsonPrep to skip this prepper and continue trying others.</p> Source code in <code>src/pytest_respect/utils.py</code> <pre><code>def add_json_prepper(type_: type | UnionType, prepper: Callable[[Any], Any]) -&gt; None:\n    \"\"\"Register a global JSON prepper for a given type, including sub-classes.\n\n    The prepper can return a few kinds of values:\n    - Simple value: encoded as-is and must be JSON serializable.\n    - Dict: encoded recursively but must have keys that are supported by the json_encoder use, which is usually str.\n    - Collection: list, tuple, set, etc will be recursively encoded as a list.\n\n    It can also raise AbortJsonPrep to skip this prepper and continue trying others.\n    \"\"\"\n    _JSON_PREPPERS.append((type_, prepper))\n</code></pre>"},{"location":"api-utils/#pytest_respect.utils.prepare_for_json_encode","title":"<code>prepare_for_json_encode(value, *, ndigits=None, allow_negative_zero=False, extra_preppers=tuple())</code>","text":"<p>Copy a structure of lists, tuples, dicts, pydantic models and numpy values into a parallel structure of dicts and lists, trying to make them JSON encodable.</p> <p>The encoding is specifically intended for writing expectation files, so it doesn't need to be reversible, and if data or precision is lost in a way that is not acceptable, then the user has the opportunity to register a custom prepper for that type.</p> <p>This library installs preppers for pydantic models and numpy arrays if those libraries are installed.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>The value to prepare for JSON encoding</p> required <code>ndigits</code> <code>int | None</code> <p>The number of digits to round floats to, or None to omit rounding</p> <code>None</code> <code>allow_negative_zero</code> <code>bool</code> <p>If False, convert negative zero to plain zero in output</p> <code>False</code> <code>extra_preppers</code> <code>Iterable[tuple[type | UnionType, Callable[[Any], Any]]]</code> <p>Additional preppers to apply before the registered ones.</p> <code>tuple()</code> Source code in <code>src/pytest_respect/utils.py</code> <pre><code>def prepare_for_json_encode(\n    value: Any,\n    *,\n    ndigits: int | None = None,\n    allow_negative_zero: bool = False,\n    extra_preppers: Iterable[tuple[type | UnionType, Callable[[Any], Any]]] = tuple(),\n) -&gt; Any:\n    \"\"\"\n    Copy a structure of lists, tuples, dicts, pydantic models and numpy values into a parallel structure of dicts and\n    lists, trying to make them JSON encodable.\n\n    The encoding is specifically intended for writing expectation files, so it doesn't need to be reversible, and if\n    data or precision is lost in a way that is not acceptable, then the user has the opportunity to register a custom\n    prepper for that type.\n\n    This library installs preppers for pydantic models and numpy arrays if those libraries are installed.\n\n    Args:\n        value: The value to prepare for JSON encoding\n        ndigits: The number of digits to round floats to, or None to omit rounding\n        allow_negative_zero: If False, convert negative zero to plain zero in output\n        extra_preppers: Additional preppers to apply before the registered ones.\n    \"\"\"\n\n    # Apply the configured preppers\n    for type_, prepper in chain(extra_preppers, _JSON_PREPPERS):\n        if isinstance(value, type_):\n            try:\n                value = prepper(value)\n                continue\n            except AbortJsonPrep:\n                pass\n\n    # Apply rounding of floats values\n    if isinstance(value, float):\n        if ndigits is not None:\n            value = round(value, ndigits)\n        if not allow_negative_zero:\n            value += 0.0\n        return value\n\n    # Return other JSON encodable values directly\n    elif isinstance(value, str | int | bool | None):\n        return value\n\n    recurse = partial(\n        prepare_for_json_encode,\n        ndigits=ndigits,\n        allow_negative_zero=allow_negative_zero,\n        extra_preppers=extra_preppers,\n    )\n\n    # Recurse into dicts and collections\n    if isinstance(value, Mapping):\n        return {recurse(key): recurse(value) for key, value in value.items()}\n    elif isinstance(value, Collection):\n        # Collections other than strings are encoded to lists\n        return [recurse(x) for x in value]\n\n    # Convert anything else to a string\n    else:\n        return str(value)\n</code></pre>"}]}